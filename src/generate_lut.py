

def n_hot_decoder( in_ ):
  hot = 0
  while in_ > 0:
    in_ = (in_ - 1) & in_
    hot += 1
  return hot

def generate_lut( width, length ):
  assert length >= 3
  assert width >= 3
  LUT = []
  for block_state in range(2**(length*width)):
    next_state = 0
    for i in range(length - 2):
      center_state = (block_state >> (length + 1 + i)) & 0x1 
      alive_count = 0
      for dy in range(0, 3):
        neighbors = (block_state >> ( dy * length + i )) & 7 
        if dy != 1:
          alive_count += n_hot_decoder(neighbors)
        else:
          alive_count += n_hot_decoder(neighbors) - center_state
      if alive_count == 3 or (alive_count == 2 and center_state == 1):
        next_state |= 1 << (length - 3 - i)
      # print(block_state, alive_count, next_state)
    LUT.append(next_state)
  return LUT

LUT = generate_lut(3, 10)

output_file = "../src/lut3x3.h"
with open(output_file, 'w') as fd:
  fd.write("uint8_t LUT[] = {\n")
  for i, entry in enumerate(LUT):
    fd.write("\t{}".format(entry))
    if i < len(LUT)-1:
      fd.write(",\n")
    else:
      fd.write("\n")
  fd.write("};\n")
  fd.write("// This was generated by hand >:D\n")
